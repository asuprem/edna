<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>edna.core.plans.executiongraph.ExecutionGraph API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>edna.core.plans.executiongraph.ExecutionGraph</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
from edna.core.tasks import SingleSourceSingleTargetTask
from edna.core.plans.physicalgraph import PhysicalGraph
from typing import List, Dict

from edna.core.tasks import TaskPrimitive
from edna.core.plans.physicalgraph import PhysicalGraph
from edna.defaults import EdnaDefault
import time
import logging


class ExecutionGraph:
    task_primitive_list: List[TaskPrimitive]
    buffer_emit_addresses: Dict[int,int]
    buffer_ingest_addresses: Dict[int,int]
    port_callable: _PortCallable
    task_order: List[int]
    logger: logging.Logger

    def __init__(self, port_range_min: int = 35000):
        &#34;&#34;&#34;TODO make a connection to the edna runtime to request a port address

        Args:
            physical_graph (PhysicalGraph): [description]
            port_range_min (int, optional): [description]. Defaults to 35000.
            port_range_max (int, optional): [description]. Defaults to 36000.
        &#34;&#34;&#34;

        
        self.buffer_emit_addresses = {}
        self.buffer_ingest_addresses = {}
        self.task_primitive_list = []
        self.task_order = []
        if port_range_min is None:
            self.port_callable = self._EdnaEnginePortCallable()
        else:
            self.port_callable = self._PortCallable(port_range_min)
        self.logger = logging.getLogger(self.__class__.__name__)
    
    def buildExecutionGraph(self, physical_graph: PhysicalGraph):
        self.logger.debug(&#34;Populating Buffer addresses for ExecutionGraph&#34;)
        self.populateBufferAddresses(physical_graph)
        depth_order = self.buildDepthOrder(physical_graph)
        self.task_order = [item[0] for item in sorted(depth_order.items(), key=lambda x:x[1],reverse=True)]
        #pdb.set_trace()
        # For each node, we create a task primitive, and go on from there...
        # Have to do this in reverse order!!!!!

        for physical_graph_node_idx in self.task_order:
            # Single Source Single Target

            if physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[0].isIngest() and \
                physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[-1].isEmit():
                # Build process:
                ingest_port = self.buffer_ingest_addresses.get(physical_graph.physical_node_list[physical_graph_node_idx].node_id, None)
                emit_port = self.buffer_emit_addresses.get(physical_graph.physical_node_list[physical_graph_node_idx].node_id, None)
                root_process = None
                for base_process_nodes in physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[1:-1]:
                    base_process_nodes.node_callable.replaceChainedProcess(root_process)
                    # del root_process
                    root_process = base_process_nodes.node_callable
                self.logger.info(&#34;Building Task Node {node} with ingest-port {ingest} and emit-port {emit}&#34;.format(
                    node=physical_graph_node_idx,
                    ingest=ingest_port,
                    emit=emit_port
                ))
                self.task_primitive_list.append(
                    SingleSourceSingleTargetTask(ingest_primitive=physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[0].node_callable,
                        emit_primitive=physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[-1].node_callable,
                        process_primitive=root_process,
                        ingest_port=ingest_port,
                        emit_port=emit_port,
                        max_buffer_size=EdnaDefault.BUFFER_MAX_SIZE,
                        max_buffer_timeout=EdnaDefault.BUFFER_MAX_TIMEOUT_S,
                        logger_name=&#34;TaskPrimitive-For-TaskNode-&#34;+str(physical_graph_node_idx)
                    )
                )
        #pdb.set_trace()

        
    def execute(self):
        for task_primitive in self.task_primitive_list:
            task_primitive.start()

        for task_primitive in self.task_primitive_list:
            task_primitive.build()



        try:
            self.logger.info(&#34;All tasks are executing&#34;)
            while True:
                time.sleep(EdnaDefault.TASK_POLL_TIMEOUT_S)
        except KeyboardInterrupt:
            self.logger.info(&#34;Keyboard interrupt received. Shutting down tasks&#34;)
            for task_primitive in self.task_primitive_list:
                task_primitive.stop()
            self.logger.info(&#34;Rejoining main thread&#34;)
            for task_primitive in self.task_primitive_list:
                task_primitive.join()
        self.logger.info(&#34;Finished Execution&#34;)


    def populateBufferAddresses(self, physical_graph: PhysicalGraph):
        for source_node_id in physical_graph.physical_nodes_edges:
            port = self.port_callable.requestNewPort()
            self.buffer_emit_addresses[source_node_id] = port
            for target_node_id in physical_graph.physical_nodes_edges[source_node_id]:
                self.buffer_ingest_addresses[target_node_id] = port

    def buildDepthOrder(self, physical_graph: PhysicalGraph):
        # Arrange the physical nodes in reverse depth order
        depth_order = {}
        self._dfsDepth(depth_order, physical_graph.physical_node_root_list, physical_graph, None)
        return depth_order

    def _dfsDepth(self,depth_order:Dict[int,int], node_idx_list, physical_graph: PhysicalGraph,parent_node_idx:int = None):
        for physical_graph_node_idx in node_idx_list:
            if physical_graph_node_idx not in depth_order:
                depth_order[physical_graph_node_idx] = 0

            if parent_node_idx is None: # is root
                depth_order[physical_graph_node_idx] = 0
            else:
                temp_depth = depth_order[parent_node_idx]+1
                if temp_depth &gt; depth_order[physical_graph_node_idx]:
                    depth_order[physical_graph_node_idx] = temp_depth
            
            self._dfsDepth(depth_order,physical_graph.getEdgesForPhysicalNodeIdx(physical_graph_node_idx), physical_graph, physical_graph_node_idx)

        



    class _PortCallable:
        def __init__(self,port_range_min: int):
            self.port = port_range_min

        def requestNewPort(self):
            self.port += 1
            return self.port - 1

    class _EdnaEnginePortCallable:
        def __init__(self):
            raise NotImplementedError()

        def requestNewPort(self):
            raise NotImplementedError()
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph"><code class="flex name class">
<span>class <span class="ident">ExecutionGraph</span></span>
<span>(</span><span>port_range_min: int = 35000)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO make a connection to the edna runtime to request a port address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>physical_graph</code></strong> :&ensp;<code>PhysicalGraph</code></dt>
<dd>[description]</dd>
<dt><strong><code>port_range_min</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 35000.</dd>
<dt><strong><code>port_range_max</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 36000.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExecutionGraph:
    task_primitive_list: List[TaskPrimitive]
    buffer_emit_addresses: Dict[int,int]
    buffer_ingest_addresses: Dict[int,int]
    port_callable: _PortCallable
    task_order: List[int]
    logger: logging.Logger

    def __init__(self, port_range_min: int = 35000):
        &#34;&#34;&#34;TODO make a connection to the edna runtime to request a port address

        Args:
            physical_graph (PhysicalGraph): [description]
            port_range_min (int, optional): [description]. Defaults to 35000.
            port_range_max (int, optional): [description]. Defaults to 36000.
        &#34;&#34;&#34;

        
        self.buffer_emit_addresses = {}
        self.buffer_ingest_addresses = {}
        self.task_primitive_list = []
        self.task_order = []
        if port_range_min is None:
            self.port_callable = self._EdnaEnginePortCallable()
        else:
            self.port_callable = self._PortCallable(port_range_min)
        self.logger = logging.getLogger(self.__class__.__name__)
    
    def buildExecutionGraph(self, physical_graph: PhysicalGraph):
        self.logger.debug(&#34;Populating Buffer addresses for ExecutionGraph&#34;)
        self.populateBufferAddresses(physical_graph)
        depth_order = self.buildDepthOrder(physical_graph)
        self.task_order = [item[0] for item in sorted(depth_order.items(), key=lambda x:x[1],reverse=True)]
        #pdb.set_trace()
        # For each node, we create a task primitive, and go on from there...
        # Have to do this in reverse order!!!!!

        for physical_graph_node_idx in self.task_order:
            # Single Source Single Target

            if physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[0].isIngest() and \
                physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[-1].isEmit():
                # Build process:
                ingest_port = self.buffer_ingest_addresses.get(physical_graph.physical_node_list[physical_graph_node_idx].node_id, None)
                emit_port = self.buffer_emit_addresses.get(physical_graph.physical_node_list[physical_graph_node_idx].node_id, None)
                root_process = None
                for base_process_nodes in physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[1:-1]:
                    base_process_nodes.node_callable.replaceChainedProcess(root_process)
                    # del root_process
                    root_process = base_process_nodes.node_callable
                self.logger.info(&#34;Building Task Node {node} with ingest-port {ingest} and emit-port {emit}&#34;.format(
                    node=physical_graph_node_idx,
                    ingest=ingest_port,
                    emit=emit_port
                ))
                self.task_primitive_list.append(
                    SingleSourceSingleTargetTask(ingest_primitive=physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[0].node_callable,
                        emit_primitive=physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[-1].node_callable,
                        process_primitive=root_process,
                        ingest_port=ingest_port,
                        emit_port=emit_port,
                        max_buffer_size=EdnaDefault.BUFFER_MAX_SIZE,
                        max_buffer_timeout=EdnaDefault.BUFFER_MAX_TIMEOUT_S,
                        logger_name=&#34;TaskPrimitive-For-TaskNode-&#34;+str(physical_graph_node_idx)
                    )
                )
        #pdb.set_trace()

        
    def execute(self):
        for task_primitive in self.task_primitive_list:
            task_primitive.start()

        for task_primitive in self.task_primitive_list:
            task_primitive.build()



        try:
            self.logger.info(&#34;All tasks are executing&#34;)
            while True:
                time.sleep(EdnaDefault.TASK_POLL_TIMEOUT_S)
        except KeyboardInterrupt:
            self.logger.info(&#34;Keyboard interrupt received. Shutting down tasks&#34;)
            for task_primitive in self.task_primitive_list:
                task_primitive.stop()
            self.logger.info(&#34;Rejoining main thread&#34;)
            for task_primitive in self.task_primitive_list:
                task_primitive.join()
        self.logger.info(&#34;Finished Execution&#34;)


    def populateBufferAddresses(self, physical_graph: PhysicalGraph):
        for source_node_id in physical_graph.physical_nodes_edges:
            port = self.port_callable.requestNewPort()
            self.buffer_emit_addresses[source_node_id] = port
            for target_node_id in physical_graph.physical_nodes_edges[source_node_id]:
                self.buffer_ingest_addresses[target_node_id] = port

    def buildDepthOrder(self, physical_graph: PhysicalGraph):
        # Arrange the physical nodes in reverse depth order
        depth_order = {}
        self._dfsDepth(depth_order, physical_graph.physical_node_root_list, physical_graph, None)
        return depth_order

    def _dfsDepth(self,depth_order:Dict[int,int], node_idx_list, physical_graph: PhysicalGraph,parent_node_idx:int = None):
        for physical_graph_node_idx in node_idx_list:
            if physical_graph_node_idx not in depth_order:
                depth_order[physical_graph_node_idx] = 0

            if parent_node_idx is None: # is root
                depth_order[physical_graph_node_idx] = 0
            else:
                temp_depth = depth_order[parent_node_idx]+1
                if temp_depth &gt; depth_order[physical_graph_node_idx]:
                    depth_order[physical_graph_node_idx] = temp_depth
            
            self._dfsDepth(depth_order,physical_graph.getEdgesForPhysicalNodeIdx(physical_graph_node_idx), physical_graph, physical_graph_node_idx)

        



    class _PortCallable:
        def __init__(self,port_range_min: int):
            self.port = port_range_min

        def requestNewPort(self):
            self.port += 1
            return self.port - 1

    class _EdnaEnginePortCallable:
        def __init__(self):
            raise NotImplementedError()

        def requestNewPort(self):
            raise NotImplementedError()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.buffer_emit_addresses"><code class="name">var <span class="ident">buffer_emit_addresses</span> : Dict[int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.buffer_ingest_addresses"><code class="name">var <span class="ident">buffer_ingest_addresses</span> : Dict[int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.logger"><code class="name">var <span class="ident">logger</span> : logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.port_callable"><code class="name">var <span class="ident">port_callable</span> : _PortCallable</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.task_order"><code class="name">var <span class="ident">task_order</span> : List[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.task_primitive_list"><code class="name">var <span class="ident">task_primitive_list</span> : List[TaskPrimitive]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.buildDepthOrder"><code class="name flex">
<span>def <span class="ident">buildDepthOrder</span></span>(<span>self, physical_graph: PhysicalGraph)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildDepthOrder(self, physical_graph: PhysicalGraph):
    # Arrange the physical nodes in reverse depth order
    depth_order = {}
    self._dfsDepth(depth_order, physical_graph.physical_node_root_list, physical_graph, None)
    return depth_order</code></pre>
</details>
</dd>
<dt id="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.buildExecutionGraph"><code class="name flex">
<span>def <span class="ident">buildExecutionGraph</span></span>(<span>self, physical_graph: PhysicalGraph)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildExecutionGraph(self, physical_graph: PhysicalGraph):
    self.logger.debug(&#34;Populating Buffer addresses for ExecutionGraph&#34;)
    self.populateBufferAddresses(physical_graph)
    depth_order = self.buildDepthOrder(physical_graph)
    self.task_order = [item[0] for item in sorted(depth_order.items(), key=lambda x:x[1],reverse=True)]
    #pdb.set_trace()
    # For each node, we create a task primitive, and go on from there...
    # Have to do this in reverse order!!!!!

    for physical_graph_node_idx in self.task_order:
        # Single Source Single Target

        if physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[0].isIngest() and \
            physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[-1].isEmit():
            # Build process:
            ingest_port = self.buffer_ingest_addresses.get(physical_graph.physical_node_list[physical_graph_node_idx].node_id, None)
            emit_port = self.buffer_emit_addresses.get(physical_graph.physical_node_list[physical_graph_node_idx].node_id, None)
            root_process = None
            for base_process_nodes in physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[1:-1]:
                base_process_nodes.node_callable.replaceChainedProcess(root_process)
                # del root_process
                root_process = base_process_nodes.node_callable
            self.logger.info(&#34;Building Task Node {node} with ingest-port {ingest} and emit-port {emit}&#34;.format(
                node=physical_graph_node_idx,
                ingest=ingest_port,
                emit=emit_port
            ))
            self.task_primitive_list.append(
                SingleSourceSingleTargetTask(ingest_primitive=physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[0].node_callable,
                    emit_primitive=physical_graph.physical_node_list[physical_graph_node_idx].internal_stream_graph.node_list[-1].node_callable,
                    process_primitive=root_process,
                    ingest_port=ingest_port,
                    emit_port=emit_port,
                    max_buffer_size=EdnaDefault.BUFFER_MAX_SIZE,
                    max_buffer_timeout=EdnaDefault.BUFFER_MAX_TIMEOUT_S,
                    logger_name=&#34;TaskPrimitive-For-TaskNode-&#34;+str(physical_graph_node_idx)
                )
            )</code></pre>
</details>
</dd>
<dt id="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self):
    for task_primitive in self.task_primitive_list:
        task_primitive.start()

    for task_primitive in self.task_primitive_list:
        task_primitive.build()



    try:
        self.logger.info(&#34;All tasks are executing&#34;)
        while True:
            time.sleep(EdnaDefault.TASK_POLL_TIMEOUT_S)
    except KeyboardInterrupt:
        self.logger.info(&#34;Keyboard interrupt received. Shutting down tasks&#34;)
        for task_primitive in self.task_primitive_list:
            task_primitive.stop()
        self.logger.info(&#34;Rejoining main thread&#34;)
        for task_primitive in self.task_primitive_list:
            task_primitive.join()
    self.logger.info(&#34;Finished Execution&#34;)</code></pre>
</details>
</dd>
<dt id="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.populateBufferAddresses"><code class="name flex">
<span>def <span class="ident">populateBufferAddresses</span></span>(<span>self, physical_graph: PhysicalGraph)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populateBufferAddresses(self, physical_graph: PhysicalGraph):
    for source_node_id in physical_graph.physical_nodes_edges:
        port = self.port_callable.requestNewPort()
        self.buffer_emit_addresses[source_node_id] = port
        for target_node_id in physical_graph.physical_nodes_edges[source_node_id]:
            self.buffer_ingest_addresses[target_node_id] = port</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="edna.core.plans.executiongraph" href="index.html">edna.core.plans.executiongraph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph" href="#edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph">ExecutionGraph</a></code></h4>
<ul class="">
<li><code><a title="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.buffer_emit_addresses" href="#edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.buffer_emit_addresses">buffer_emit_addresses</a></code></li>
<li><code><a title="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.buffer_ingest_addresses" href="#edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.buffer_ingest_addresses">buffer_ingest_addresses</a></code></li>
<li><code><a title="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.buildDepthOrder" href="#edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.buildDepthOrder">buildDepthOrder</a></code></li>
<li><code><a title="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.buildExecutionGraph" href="#edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.buildExecutionGraph">buildExecutionGraph</a></code></li>
<li><code><a title="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.execute" href="#edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.execute">execute</a></code></li>
<li><code><a title="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.logger" href="#edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.logger">logger</a></code></li>
<li><code><a title="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.populateBufferAddresses" href="#edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.populateBufferAddresses">populateBufferAddresses</a></code></li>
<li><code><a title="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.port_callable" href="#edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.port_callable">port_callable</a></code></li>
<li><code><a title="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.task_order" href="#edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.task_order">task_order</a></code></li>
<li><code><a title="edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.task_primitive_list" href="#edna.core.plans.executiongraph.ExecutionGraph.ExecutionGraph.task_primitive_list">task_primitive_list</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>