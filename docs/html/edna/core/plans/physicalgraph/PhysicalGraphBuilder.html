<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>edna.core.plans.physicalgraph.PhysicalGraphBuilder API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>edna.core.plans.physicalgraph.PhysicalGraphBuilder</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
from typing import List


from edna.core.execution.context import StreamingContext

from edna.core.plans.physicalgraph import PhysicalGraph
from edna.core.plans.physicalgraph import PhysicalGraphNode
from edna.core.plans.streamgraph import StreamGraph

from edna.core.plans.streamgraph import SingleOutputStreamGraphNode
from edna.types.enums import SingleOutputStreamGraphNodeType
from edna.types.enums import SingleOutputStreamGraphNodeProcessType

from edna.ingest.streaming._BufferedIngest import _BufferedIngest
from edna.emit._BufferedEmit import _BufferedEmit
from edna.serializers import MsgPackBufferedSerializer


class PhysicalGraphBuilder:
    &#34;&#34;&#34;PhysicalGraphBuilder builds a PhysicalGraph representing a physical plan for a StreamGraph.
    &#34;&#34;&#34;

    

    @staticmethod
    def convertStreamGraph(context: StreamingContext) -&gt; PhysicalGraph:
        &#34;&#34;&#34;Converts a logical plan in the StreamGraph to a PhysicalGraph 
        representing a physical plan .

        Args:
            context (StreamingContext): The context containing the logical plan

        Returns:
            PhysicalGraph: The PhysicalGraph representing the physical plan of
                the logical plan in the provided context
        &#34;&#34;&#34;
        # For each stream graph node
        physical_graph = PhysicalGraph()
        
        PhysicalGraphBuilder.addNodesAndChildren(context.logical_stream_graph.root_list, physical_graph, context)
        return physical_graph
        

            
    @staticmethod
    def addNodesAndChildren(node_list: List[int], 
                            physical_graph: PhysicalGraph, 
                            context: StreamingContext,
                            parent_node_id : int= None):
        &#34;&#34;&#34;Recursively adds each StreamGraphNode and its DAG children through a DFS to the PhysicalGraph.

        Args:
            node_list (List[int]): List of indices of each child StreamGraphNode
                for a parent StreamGraphNode in the StreamGraph of the provided context.
            physical_graph (PhysicalGraph): The PhysicalGraph to update
            context (StreamingContext): A `StreamingContext` instance
            parent_node_id (int, optional): The id of the parent StreamGraphNode for each child StreamGraphNode
                in `node_list`. Defaults to None if `node_list` contains root nodes
        &#34;&#34;&#34;


        for stream_node_idx in node_list:
            #pdb.set_trace()
            # This is an ingest node. We will create a new PhysicalGraphNode.
            if context.logical_stream_graph.node_list[stream_node_idx].isIngest():
                physical_graph_node_id = context.getNewPhysicalNodeId()
                physical_graph.addPhysicalGraphNode(PhysicalGraphNode(node_id=physical_graph_node_id))
                # Then we add nodes to the head...This will also update the dictionaries inside
                physical_graph.insertIngestNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])

            # For an emit node, we will need to first check if the node containing the prior is chainable
            # If not, we need to add a new node
            if context.logical_stream_graph.node_list[stream_node_idx].isEmit():
                # so the prior is represented in parent_node_id...
                #pdb.set_trace()
                if physical_graph.getHeadByStreamNodeId(parent_node_id).isChainable():
                    physical_graph.insertEmitNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])

                else:   # here we need a buffer ingest to point to the parent...
                    # We will need to add an edge, so we need to store the prior physical node id
                    # Note -- how to handle case when the prior node is a split??? TODO later.
                    prior_physical_node_id = physical_graph.getHeadByStreamNodeId(parent_node_id).getPhysicalNodeIdOfHead()
                    physical_graph_node_id = context.getNewPhysicalNodeId()
                    physical_graph.addPhysicalGraphNode(PhysicalGraphNode(node_id=physical_graph_node_id))
                    physical_graph.insertIngestNodeInHead(PhysicalGraphBuilder.buildBufferedIngest(context.getNewStreamingNodeId(), prior_physical_node_id))
                    physical_graph.insertEmitNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])
                    physical_graph.addEdge(prior_physical_node_id, physical_graph_node_id)

            if context.logical_stream_graph.node_list[stream_node_idx].isProcess():
                # If a standard process (not flatten/aggregate)
                create_node_flag = False
                emit_node_flag = False
                if context.logical_stream_graph.node_list[stream_node_idx].process_node_type == SingleOutputStreamGraphNodeProcessType.MAP:
                    if physical_graph.getHeadByStreamNodeId(parent_node_id).isChainable():
                        #pdb.set_trace()
                        physical_graph.insertProcessNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])
                    else:
                        # In this case, it is not chainable so we will create it later
                        create_node_flag = True
                if context.logical_stream_graph.node_list[stream_node_idx].process_node_type == SingleOutputStreamGraphNodeProcessType.FILTER \
                    or context.logical_stream_graph.node_list[stream_node_idx].process_node_type == SingleOutputStreamGraphNodeProcessType.FLATTEN:
                    # These are pseudoemits
                    emit_node_flag = True
                    if physical_graph.getHeadByStreamNodeId(parent_node_id).isChainable():
                        physical_graph.insertProcessNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])
                    else:
                        create_node_flag = True
                if context.logical_stream_graph.node_list[stream_node_idx].process_node_type == SingleOutputStreamGraphNodeProcessType.AGGREGATE:
                    # This is a pseudoingest. So if the prior head is chainable, we need to close it.
                    if physical_graph.getHeadByStreamNodeId(parent_node_id).isChainable():
                        physical_graph.insertEmitNodeInHead(PhysicalGraphBuilder.buildBufferedEmit(context.getNewStreamingNodeId()))

                    else:
                        create_node_flag = True

                    
                if create_node_flag:
                    # We create a new physical graph node, add a buffered ingest
                    # then we add the stream graph node
                    prior_physical_node_id = physical_graph.getPhysicalNodeIdOfHead()
                    physical_graph_node_id = context.getNewPhysicalNodeId()
                    physical_graph.addPhysicalGraphNode(PhysicalGraphNode(node_id=physical_graph_node_id))
                    physical_graph.insertIngestNodeInHead(PhysicalGraphBuilder.buildBufferedIngest(context.getNewStreamingNodeId(), prior_physical_node_id))
                    physical_graph.insertProcessNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])
                    physical_graph.addEdge(prior_physical_node_id, physical_graph_node_id)


                if emit_node_flag:
                    # we close the current node with a buffer emit
                    physical_graph.insertEmitNodeInHead(PhysicalGraphBuilder.buildBufferedEmit(context.getNewStreamingNodeId()))
                    # TODO add placeholder edge?????

            # If there are children, 

            PhysicalGraphBuilder.addNodesAndChildren(context.logical_stream_graph.getEdgesForNodeIdx(stream_node_idx),physical_graph,context, stream_node_idx)

        #return physical_graph

    @staticmethod
    def buildBufferedIngest(buffered_ingest_node_id: int, receive_from_physical_node_id: int) -&gt; SingleOutputStreamGraphNode:
        &#34;&#34;&#34;Builds a StreamGraphNode with a `_BufferedIngest` that records some metadata 
        about the source node for this ingest node.

        Args:
            buffered_ingest_node_id (int): A unique node id for this StreamGraphNode
            receive_from_physical_node_id (int): The node id of the PhysicalGraphNode containing
                the parent StreamGraphNode

        Returns:
            SingleOutputStreamGraphNode: A StreamGraphNode containing the `_BufferedIngest`
        &#34;&#34;&#34;
        return SingleOutputStreamGraphNode(node_type=SingleOutputStreamGraphNodeType.INGEST, 
                        node_id=buffered_ingest_node_id, 
                        name=&#34;buffer_ingest&#34;, 
                        node_callable=_BufferedIngest(serializer=MsgPackBufferedSerializer(),
                                                      receive_from_node_id=receive_from_physical_node_id))

    @staticmethod
    def buildBufferedEmit(buffered_emit_node_id: int) -&gt; SingleOutputStreamGraphNode:
        &#34;&#34;&#34;Builds a StreamGraphNode with a `_BufferedEmit` that records some metadata 
        about the source node for this ingest node.

        Args:
            buffered_emit_node_id (int): A unique node id for this StreamGraphNode

        Returns:
            SingleOutputStreamGraphNode: A StreamGraphNode containing the `_BufferedEmit`
        &#34;&#34;&#34;
        return SingleOutputStreamGraphNode(node_type=SingleOutputStreamGraphNodeType.EMIT,
                            node_id=buffered_emit_node_id,
                            name=&#34;buffer_emit&#34;,
                            node_callable=_BufferedEmit(serializer=MsgPackBufferedSerializer()))    #TODO add constants for batch size...

&#34;&#34;&#34;
completed_nodes = {}
StreamGraphToPhysicalGraphNodeDictioanry = {}
PhysicalIdsToPhysicalNodeDictionary = {}
BufferEdges = {}
JoinPlaceholders = {}
addNodesAndChildren(streamgraph.root_nodes, root=None)

&gt;addNodesAndChildren(node_list, root_node_id):
for each stream_graph_node in root_nodes:
    #stream_graph_node_type = StreamGraphNodeType.SINGLE_OUTPUT_STREAM (or split, join)
    #process_node_type=SingleOutputStreamGraphNodeProcessType.FILTER,
    - if stream_graph_node.isIngest()
        - get new physical graph node id
        - create a new PhysicalGraphNode(ingestNode)
        - add to PhysicalIdsToPhysicalNodeDictionary --&gt; {physical_graph_node.node_id = PhysicalGraphNode}
        - add to StreamGraphToPhysicalGraphNodeDictionary -&gt;  {stream_graph_node.node_id = physical_graph_node.node_id}

    - if stream_graph_node.isEmit():
        physical_graph_node_id = StreamGraphToPhysicalGraphNodeDictionary[root_node_id]
        if getPhysicalNodeFromId(physical_graph_node_id).isChainable():
            getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(stream_graph_node)
            getPhysicalNodeFromId(physical_graph_node_id).setIsNotChainable()
        else:
            get new physical graph node id
            create a new PhysicalGraphNode(bufferIngest)
            add to PhysicalIdsToPhysicalNodeDictionary --&gt; {physical_graph_node.node_id = PhysicalGraphNode}
            add to StreamGraphToPhysicalGraphNodeDictionary -&gt;  {stream_graph_node.node_id = physical_graph_node.node_id}
            parent_physical_graph_node_id = StreamGraphToPhysicalGraphNodeDictionary[root_node_id]
            BufferEdges[parent_physical_graph_node_id].append(physical_graph_node_id)
            getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(stream_graph_node)
            getPhysicalNodeFromId(physical_graph_node_id).setIsNotChainable()
            # THIS IS NOT NEEDED --&gt; BufferEdges[parent_physical_graph_node_id] = [] &lt;-- BECAUSE THIS IS EMIT NODE


    - if stream_graph_node.isProcess():
        create_node_flag = False
        emit_node_flag = False
        if stream_graph_node.process_node_type == SingleOutputStreamGraphNodeProcessType.MAP:
            physical_graph_node_id = StreamGraphToPhysicalGraphNodeDictionary[root_node_id]
            if getPhysicalNodeFromId(physical_graph_node_id).isChainable():
                getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(stream_graph_node)
            else:
                create_node_flag = True # we will create node later below
        elif FILTER:    # this is a sink node
            physical_graph_node_id = StreamGraphToPhysicalGraphNodeDictionary[root_node_id]
            if getPhysicalNodeFromId(physical_graph_node_id).isChainable():
                getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(stream_graph_node)
                getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(buffer_emit)   # basically a pseudonode that just tells executionplancreator in the future that this is a buffer_emit
                getPhysicalNodeFromId(physical_graph_node_id).setIsNotChainable()
            else:
                create_node_flag = True
                emit_node_flag = True
        elif FLATTEN: # this is also a sink node
            physical_graph_node_id = StreamGraphToPhysicalGraphNodeDictionary[root_node_id]
            if getPhysicalNodeFromId(physical_graph_node_id).isChainable():
                getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(stream_graph_node)
                getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(buffer_emit)
                getPhysicalNodeFromId(physical_graph_node_id).setIsNotChainable()
            else:
                create_node_flag = True
                emit_node_flag = True
        elif AGGREGATE: # this is a source node, so we have to check if the parent is chainable. if so, we need to add the emit to it.
            physical_graph_node_id = StreamGraphToPhysicalGraphNodeDictionary[root_node_id]
            if getPhysicalNodeFromId(physical_graph_node_id).isChainable():
                getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(stream_graph_node)
                getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(buffer_emit)
                getPhysicalNodeFromId(physical_graph_node_id).setIsNotChainable()
            else:
                create_node_flag = True
                emit_node_flag = True
        else:
            raise NotImplementedError()

        if create_node_flag:
            get new physical graph node id
            create a new PhysicalGraphNode(bufferIngest)
            add to PhysicalIdsToPhysicalNodeDictionary --&gt; {physical_graph_node.node_id = PhysicalGraphNode}
            add to StreamGraphToPhysicalGraphNodeDictionary -&gt;  {stream_graph_node.node_id = physical_graph_node.node_id}
            parent_physical_graph_node_id = StreamGraphToPhysicalGraphNodeDictionary[root_node_id]
            BufferEdges[parent_physical_graph_node_id].append(physical_graph_node_id)
            if emit_node_flag:
                getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(stream_graph_node)
                getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(buffer_emit)
                getPhysicalNodeFromId(physical_graph_node_id).setIsNotChainable()
                BufferEdges[parent_physical_graph_node_id] = []



    - if stream_graph_node.isSplit()    # This is an emit (ish)
        physical_graph_node_id = StreamGraphToPhysicalGraphNodeDictionary[root_node_id]
        if not getPhysicalNodeFromId(physical_graph_node_id).isChainable():
            physical_graph_node_id = get new physical graph node id
            create a new PhysicalGraphNode(bufferIngest)
            add to PhysicalIdsToPhysicalNodeDictionary --&gt; {physical_graph_node.node_id = PhysicalGraphNode}
            add to StreamGraphToPhysicalGraphNodeDictionary -&gt;  {stream_graph_node.node_id = physical_graph_node.node_id}
            parent_physical_graph_node_id = StreamGraphToPhysicalGraphNodeDictionary[root_node_id]
            BufferEdges[parent_physical_graph_node_id].append(physical_graph_node_id)

        if getPhysicalNodeFromId(physical_graph_node_id).isChainable(): # This is a sink node, btw...
            getPhysicalNodeFromId(physical_graph_node_id).addSplitStreamGraphNode(stream_graph_node)
            getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(split_buffer_emit) # basically tell executionbuilder that this physicalgraphnode ends in a splitnode, so that we can build the correct task primitive
            getPhysicalNodeFromId(physical_graph_node_id).setIsNotChainable()
            BufferEdges[parent_physical_graph_node_id] = []

    - if stream_graph_node.isJoin(): This is a source (ish)
        physical_graph_node_id = StreamGraphToPhysicalGraphNodeDictionary[root_node_id]
        if getPhysicalNodeFromId(physical_graph_node_id).isChainable():
            getPhysicalNodeFromId(physical_graph_node_id).addStreamGraphNode(buffer_emit)
            getPhysicalNodeFromId(physical_graph_node_id).setIsNotChainable()
            BufferEdges[parent_physical_graph_node_id] = []
        
        physical_graph_node_id = get new physical graph node id
        create a new PhysicalGraphNode(joinIngest)  # joinIngest takes in the stream_node_ids of the parents. This should already be present inside the node, actually
        add to PhysicalIdsToPhysicalNodeDictionary --&gt; {physical_graph_node.node_id = PhysicalGraphNode}
        add to StreamGraphToPhysicalGraphNodeDictionary -&gt;  {stream_graph_node.node_id = physical_graph_node.node_id}
        for # TODO later. basically we need a way to identify where the joins are coming from, i.e. to specifically idetify which port of which physicalgraphnode it is comingn from
            - example -- when join comes from one of the splits of a node, how to represent this???
            - Somehow need to deal with the `snafu` of DataStream and SplitStream...





    completed_nodes.add(stream_graph_node.node_id)
    BufferEdges[stream_graph_node.node_id] = []
        # Node, we need a secondary buffer to store bufferedgees for joinnodes where we haven&#39;t yet added the second stream...
    addNodesAndChildren(stream_graph_node.getChildren(), stream_graph_node.node_id)

    







&#34;&#34;&#34;

&#34;&#34;&#34;This represents a physical graph of physical graph nodes
    Physical graph nodes contain streamgraphnodes in a physicalnodegraph.
        Physicalnodegraphs are DAGS with no branching (except in the leaf) 
        root - internal - internal - leaf

        physical graph iterates through nodes in streamgraph
            for each node, check if it is a join node
                if so, create a new physicalnode with it, and store the edges to its previous physicalnodes (which we can get with our streamgraphnode-to-physicalnode dictionary)
            if not join, then check which single node it connects to and the associated physicalnode
            check if this node can be added to the physicalnode. if so, update the streamgraphnode-to-physicalnode dictionary
            if node, create a physicalnode with it
                physicalnode returns a node wrapping the streamgraphnode
                physicalnode returns a specific type of node given the streamgraphnode it was just given
                    singleoutputnode -- we can add new nodes to it (it can have a join, emit, or process as the root node)
                    splitoutputnode -- we cannot add new nodes to it (it can have a join, emit, or process as the root node)

            add this physicalnode to the physicalgraph
            add an edge between this physicalnode and the previous physicalnode

&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder"><code class="flex name class">
<span>class <span class="ident">PhysicalGraphBuilder</span></span>
</code></dt>
<dd>
<div class="desc"><p>PhysicalGraphBuilder builds a PhysicalGraph representing a physical plan for a StreamGraph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhysicalGraphBuilder:
    &#34;&#34;&#34;PhysicalGraphBuilder builds a PhysicalGraph representing a physical plan for a StreamGraph.
    &#34;&#34;&#34;

    

    @staticmethod
    def convertStreamGraph(context: StreamingContext) -&gt; PhysicalGraph:
        &#34;&#34;&#34;Converts a logical plan in the StreamGraph to a PhysicalGraph 
        representing a physical plan .

        Args:
            context (StreamingContext): The context containing the logical plan

        Returns:
            PhysicalGraph: The PhysicalGraph representing the physical plan of
                the logical plan in the provided context
        &#34;&#34;&#34;
        # For each stream graph node
        physical_graph = PhysicalGraph()
        
        PhysicalGraphBuilder.addNodesAndChildren(context.logical_stream_graph.root_list, physical_graph, context)
        return physical_graph
        

            
    @staticmethod
    def addNodesAndChildren(node_list: List[int], 
                            physical_graph: PhysicalGraph, 
                            context: StreamingContext,
                            parent_node_id : int= None):
        &#34;&#34;&#34;Recursively adds each StreamGraphNode and its DAG children through a DFS to the PhysicalGraph.

        Args:
            node_list (List[int]): List of indices of each child StreamGraphNode
                for a parent StreamGraphNode in the StreamGraph of the provided context.
            physical_graph (PhysicalGraph): The PhysicalGraph to update
            context (StreamingContext): A `StreamingContext` instance
            parent_node_id (int, optional): The id of the parent StreamGraphNode for each child StreamGraphNode
                in `node_list`. Defaults to None if `node_list` contains root nodes
        &#34;&#34;&#34;


        for stream_node_idx in node_list:
            #pdb.set_trace()
            # This is an ingest node. We will create a new PhysicalGraphNode.
            if context.logical_stream_graph.node_list[stream_node_idx].isIngest():
                physical_graph_node_id = context.getNewPhysicalNodeId()
                physical_graph.addPhysicalGraphNode(PhysicalGraphNode(node_id=physical_graph_node_id))
                # Then we add nodes to the head...This will also update the dictionaries inside
                physical_graph.insertIngestNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])

            # For an emit node, we will need to first check if the node containing the prior is chainable
            # If not, we need to add a new node
            if context.logical_stream_graph.node_list[stream_node_idx].isEmit():
                # so the prior is represented in parent_node_id...
                #pdb.set_trace()
                if physical_graph.getHeadByStreamNodeId(parent_node_id).isChainable():
                    physical_graph.insertEmitNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])

                else:   # here we need a buffer ingest to point to the parent...
                    # We will need to add an edge, so we need to store the prior physical node id
                    # Note -- how to handle case when the prior node is a split??? TODO later.
                    prior_physical_node_id = physical_graph.getHeadByStreamNodeId(parent_node_id).getPhysicalNodeIdOfHead()
                    physical_graph_node_id = context.getNewPhysicalNodeId()
                    physical_graph.addPhysicalGraphNode(PhysicalGraphNode(node_id=physical_graph_node_id))
                    physical_graph.insertIngestNodeInHead(PhysicalGraphBuilder.buildBufferedIngest(context.getNewStreamingNodeId(), prior_physical_node_id))
                    physical_graph.insertEmitNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])
                    physical_graph.addEdge(prior_physical_node_id, physical_graph_node_id)

            if context.logical_stream_graph.node_list[stream_node_idx].isProcess():
                # If a standard process (not flatten/aggregate)
                create_node_flag = False
                emit_node_flag = False
                if context.logical_stream_graph.node_list[stream_node_idx].process_node_type == SingleOutputStreamGraphNodeProcessType.MAP:
                    if physical_graph.getHeadByStreamNodeId(parent_node_id).isChainable():
                        #pdb.set_trace()
                        physical_graph.insertProcessNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])
                    else:
                        # In this case, it is not chainable so we will create it later
                        create_node_flag = True
                if context.logical_stream_graph.node_list[stream_node_idx].process_node_type == SingleOutputStreamGraphNodeProcessType.FILTER \
                    or context.logical_stream_graph.node_list[stream_node_idx].process_node_type == SingleOutputStreamGraphNodeProcessType.FLATTEN:
                    # These are pseudoemits
                    emit_node_flag = True
                    if physical_graph.getHeadByStreamNodeId(parent_node_id).isChainable():
                        physical_graph.insertProcessNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])
                    else:
                        create_node_flag = True
                if context.logical_stream_graph.node_list[stream_node_idx].process_node_type == SingleOutputStreamGraphNodeProcessType.AGGREGATE:
                    # This is a pseudoingest. So if the prior head is chainable, we need to close it.
                    if physical_graph.getHeadByStreamNodeId(parent_node_id).isChainable():
                        physical_graph.insertEmitNodeInHead(PhysicalGraphBuilder.buildBufferedEmit(context.getNewStreamingNodeId()))

                    else:
                        create_node_flag = True

                    
                if create_node_flag:
                    # We create a new physical graph node, add a buffered ingest
                    # then we add the stream graph node
                    prior_physical_node_id = physical_graph.getPhysicalNodeIdOfHead()
                    physical_graph_node_id = context.getNewPhysicalNodeId()
                    physical_graph.addPhysicalGraphNode(PhysicalGraphNode(node_id=physical_graph_node_id))
                    physical_graph.insertIngestNodeInHead(PhysicalGraphBuilder.buildBufferedIngest(context.getNewStreamingNodeId(), prior_physical_node_id))
                    physical_graph.insertProcessNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])
                    physical_graph.addEdge(prior_physical_node_id, physical_graph_node_id)


                if emit_node_flag:
                    # we close the current node with a buffer emit
                    physical_graph.insertEmitNodeInHead(PhysicalGraphBuilder.buildBufferedEmit(context.getNewStreamingNodeId()))
                    # TODO add placeholder edge?????

            # If there are children, 

            PhysicalGraphBuilder.addNodesAndChildren(context.logical_stream_graph.getEdgesForNodeIdx(stream_node_idx),physical_graph,context, stream_node_idx)

        #return physical_graph

    @staticmethod
    def buildBufferedIngest(buffered_ingest_node_id: int, receive_from_physical_node_id: int) -&gt; SingleOutputStreamGraphNode:
        &#34;&#34;&#34;Builds a StreamGraphNode with a `_BufferedIngest` that records some metadata 
        about the source node for this ingest node.

        Args:
            buffered_ingest_node_id (int): A unique node id for this StreamGraphNode
            receive_from_physical_node_id (int): The node id of the PhysicalGraphNode containing
                the parent StreamGraphNode

        Returns:
            SingleOutputStreamGraphNode: A StreamGraphNode containing the `_BufferedIngest`
        &#34;&#34;&#34;
        return SingleOutputStreamGraphNode(node_type=SingleOutputStreamGraphNodeType.INGEST, 
                        node_id=buffered_ingest_node_id, 
                        name=&#34;buffer_ingest&#34;, 
                        node_callable=_BufferedIngest(serializer=MsgPackBufferedSerializer(),
                                                      receive_from_node_id=receive_from_physical_node_id))

    @staticmethod
    def buildBufferedEmit(buffered_emit_node_id: int) -&gt; SingleOutputStreamGraphNode:
        &#34;&#34;&#34;Builds a StreamGraphNode with a `_BufferedEmit` that records some metadata 
        about the source node for this ingest node.

        Args:
            buffered_emit_node_id (int): A unique node id for this StreamGraphNode

        Returns:
            SingleOutputStreamGraphNode: A StreamGraphNode containing the `_BufferedEmit`
        &#34;&#34;&#34;
        return SingleOutputStreamGraphNode(node_type=SingleOutputStreamGraphNodeType.EMIT,
                            node_id=buffered_emit_node_id,
                            name=&#34;buffer_emit&#34;,
                            node_callable=_BufferedEmit(serializer=MsgPackBufferedSerializer()))    #TODO add constants for batch size...</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder.addNodesAndChildren"><code class="name flex">
<span>def <span class="ident">addNodesAndChildren</span></span>(<span>node_list: List[int], physical_graph: PhysicalGraph, context: StreamingContext, parent_node_id: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively adds each StreamGraphNode and its DAG children through a DFS to the PhysicalGraph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_list</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>List of indices of each child StreamGraphNode
for a parent StreamGraphNode in the StreamGraph of the provided context.</dd>
<dt><strong><code>physical_graph</code></strong> :&ensp;<code>PhysicalGraph</code></dt>
<dd>The PhysicalGraph to update</dd>
<dt><strong><code>context</code></strong> :&ensp;<code>StreamingContext</code></dt>
<dd>A <code>StreamingContext</code> instance</dd>
<dt><strong><code>parent_node_id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The id of the parent StreamGraphNode for each child StreamGraphNode
in <code>node_list</code>. Defaults to None if <code>node_list</code> contains root nodes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def addNodesAndChildren(node_list: List[int], 
                        physical_graph: PhysicalGraph, 
                        context: StreamingContext,
                        parent_node_id : int= None):
    &#34;&#34;&#34;Recursively adds each StreamGraphNode and its DAG children through a DFS to the PhysicalGraph.

    Args:
        node_list (List[int]): List of indices of each child StreamGraphNode
            for a parent StreamGraphNode in the StreamGraph of the provided context.
        physical_graph (PhysicalGraph): The PhysicalGraph to update
        context (StreamingContext): A `StreamingContext` instance
        parent_node_id (int, optional): The id of the parent StreamGraphNode for each child StreamGraphNode
            in `node_list`. Defaults to None if `node_list` contains root nodes
    &#34;&#34;&#34;


    for stream_node_idx in node_list:
        #pdb.set_trace()
        # This is an ingest node. We will create a new PhysicalGraphNode.
        if context.logical_stream_graph.node_list[stream_node_idx].isIngest():
            physical_graph_node_id = context.getNewPhysicalNodeId()
            physical_graph.addPhysicalGraphNode(PhysicalGraphNode(node_id=physical_graph_node_id))
            # Then we add nodes to the head...This will also update the dictionaries inside
            physical_graph.insertIngestNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])

        # For an emit node, we will need to first check if the node containing the prior is chainable
        # If not, we need to add a new node
        if context.logical_stream_graph.node_list[stream_node_idx].isEmit():
            # so the prior is represented in parent_node_id...
            #pdb.set_trace()
            if physical_graph.getHeadByStreamNodeId(parent_node_id).isChainable():
                physical_graph.insertEmitNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])

            else:   # here we need a buffer ingest to point to the parent...
                # We will need to add an edge, so we need to store the prior physical node id
                # Note -- how to handle case when the prior node is a split??? TODO later.
                prior_physical_node_id = physical_graph.getHeadByStreamNodeId(parent_node_id).getPhysicalNodeIdOfHead()
                physical_graph_node_id = context.getNewPhysicalNodeId()
                physical_graph.addPhysicalGraphNode(PhysicalGraphNode(node_id=physical_graph_node_id))
                physical_graph.insertIngestNodeInHead(PhysicalGraphBuilder.buildBufferedIngest(context.getNewStreamingNodeId(), prior_physical_node_id))
                physical_graph.insertEmitNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])
                physical_graph.addEdge(prior_physical_node_id, physical_graph_node_id)

        if context.logical_stream_graph.node_list[stream_node_idx].isProcess():
            # If a standard process (not flatten/aggregate)
            create_node_flag = False
            emit_node_flag = False
            if context.logical_stream_graph.node_list[stream_node_idx].process_node_type == SingleOutputStreamGraphNodeProcessType.MAP:
                if physical_graph.getHeadByStreamNodeId(parent_node_id).isChainable():
                    #pdb.set_trace()
                    physical_graph.insertProcessNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])
                else:
                    # In this case, it is not chainable so we will create it later
                    create_node_flag = True
            if context.logical_stream_graph.node_list[stream_node_idx].process_node_type == SingleOutputStreamGraphNodeProcessType.FILTER \
                or context.logical_stream_graph.node_list[stream_node_idx].process_node_type == SingleOutputStreamGraphNodeProcessType.FLATTEN:
                # These are pseudoemits
                emit_node_flag = True
                if physical_graph.getHeadByStreamNodeId(parent_node_id).isChainable():
                    physical_graph.insertProcessNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])
                else:
                    create_node_flag = True
            if context.logical_stream_graph.node_list[stream_node_idx].process_node_type == SingleOutputStreamGraphNodeProcessType.AGGREGATE:
                # This is a pseudoingest. So if the prior head is chainable, we need to close it.
                if physical_graph.getHeadByStreamNodeId(parent_node_id).isChainable():
                    physical_graph.insertEmitNodeInHead(PhysicalGraphBuilder.buildBufferedEmit(context.getNewStreamingNodeId()))

                else:
                    create_node_flag = True

                
            if create_node_flag:
                # We create a new physical graph node, add a buffered ingest
                # then we add the stream graph node
                prior_physical_node_id = physical_graph.getPhysicalNodeIdOfHead()
                physical_graph_node_id = context.getNewPhysicalNodeId()
                physical_graph.addPhysicalGraphNode(PhysicalGraphNode(node_id=physical_graph_node_id))
                physical_graph.insertIngestNodeInHead(PhysicalGraphBuilder.buildBufferedIngest(context.getNewStreamingNodeId(), prior_physical_node_id))
                physical_graph.insertProcessNodeInHead(context.logical_stream_graph.node_list[stream_node_idx])
                physical_graph.addEdge(prior_physical_node_id, physical_graph_node_id)


            if emit_node_flag:
                # we close the current node with a buffer emit
                physical_graph.insertEmitNodeInHead(PhysicalGraphBuilder.buildBufferedEmit(context.getNewStreamingNodeId()))
                # TODO add placeholder edge?????

        # If there are children, 

        PhysicalGraphBuilder.addNodesAndChildren(context.logical_stream_graph.getEdgesForNodeIdx(stream_node_idx),physical_graph,context, stream_node_idx)</code></pre>
</details>
</dd>
<dt id="edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder.buildBufferedEmit"><code class="name flex">
<span>def <span class="ident">buildBufferedEmit</span></span>(<span>buffered_emit_node_id: int) ‑> <a title="edna.core.plans.streamgraph.SingleOutputStreamGraphNode.SingleOutputStreamGraphNode" href="../streamgraph/SingleOutputStreamGraphNode.html#edna.core.plans.streamgraph.SingleOutputStreamGraphNode.SingleOutputStreamGraphNode">SingleOutputStreamGraphNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Builds a StreamGraphNode with a <code>_BufferedEmit</code> that records some metadata
about the source node for this ingest node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buffered_emit_node_id</code></strong> :&ensp;<code>int</code></dt>
<dd>A unique node id for this StreamGraphNode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SingleOutputStreamGraphNode</code></dt>
<dd>A StreamGraphNode containing the <code>_BufferedEmit</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def buildBufferedEmit(buffered_emit_node_id: int) -&gt; SingleOutputStreamGraphNode:
    &#34;&#34;&#34;Builds a StreamGraphNode with a `_BufferedEmit` that records some metadata 
    about the source node for this ingest node.

    Args:
        buffered_emit_node_id (int): A unique node id for this StreamGraphNode

    Returns:
        SingleOutputStreamGraphNode: A StreamGraphNode containing the `_BufferedEmit`
    &#34;&#34;&#34;
    return SingleOutputStreamGraphNode(node_type=SingleOutputStreamGraphNodeType.EMIT,
                        node_id=buffered_emit_node_id,
                        name=&#34;buffer_emit&#34;,
                        node_callable=_BufferedEmit(serializer=MsgPackBufferedSerializer()))    #TODO add constants for batch size...</code></pre>
</details>
</dd>
<dt id="edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder.buildBufferedIngest"><code class="name flex">
<span>def <span class="ident">buildBufferedIngest</span></span>(<span>buffered_ingest_node_id: int, receive_from_physical_node_id: int) ‑> <a title="edna.core.plans.streamgraph.SingleOutputStreamGraphNode.SingleOutputStreamGraphNode" href="../streamgraph/SingleOutputStreamGraphNode.html#edna.core.plans.streamgraph.SingleOutputStreamGraphNode.SingleOutputStreamGraphNode">SingleOutputStreamGraphNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Builds a StreamGraphNode with a <code>_BufferedIngest</code> that records some metadata
about the source node for this ingest node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buffered_ingest_node_id</code></strong> :&ensp;<code>int</code></dt>
<dd>A unique node id for this StreamGraphNode</dd>
<dt><strong><code>receive_from_physical_node_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The node id of the PhysicalGraphNode containing
the parent StreamGraphNode</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SingleOutputStreamGraphNode</code></dt>
<dd>A StreamGraphNode containing the <code>_BufferedIngest</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def buildBufferedIngest(buffered_ingest_node_id: int, receive_from_physical_node_id: int) -&gt; SingleOutputStreamGraphNode:
    &#34;&#34;&#34;Builds a StreamGraphNode with a `_BufferedIngest` that records some metadata 
    about the source node for this ingest node.

    Args:
        buffered_ingest_node_id (int): A unique node id for this StreamGraphNode
        receive_from_physical_node_id (int): The node id of the PhysicalGraphNode containing
            the parent StreamGraphNode

    Returns:
        SingleOutputStreamGraphNode: A StreamGraphNode containing the `_BufferedIngest`
    &#34;&#34;&#34;
    return SingleOutputStreamGraphNode(node_type=SingleOutputStreamGraphNodeType.INGEST, 
                    node_id=buffered_ingest_node_id, 
                    name=&#34;buffer_ingest&#34;, 
                    node_callable=_BufferedIngest(serializer=MsgPackBufferedSerializer(),
                                                  receive_from_node_id=receive_from_physical_node_id))</code></pre>
</details>
</dd>
<dt id="edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder.convertStreamGraph"><code class="name flex">
<span>def <span class="ident">convertStreamGraph</span></span>(<span>context: StreamingContext) ‑> PhysicalGraph</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a logical plan in the StreamGraph to a PhysicalGraph
representing a physical plan .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>StreamingContext</code></dt>
<dd>The context containing the logical plan</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>PhysicalGraph</code></dt>
<dd>The PhysicalGraph representing the physical plan of
the logical plan in the provided context</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def convertStreamGraph(context: StreamingContext) -&gt; PhysicalGraph:
    &#34;&#34;&#34;Converts a logical plan in the StreamGraph to a PhysicalGraph 
    representing a physical plan .

    Args:
        context (StreamingContext): The context containing the logical plan

    Returns:
        PhysicalGraph: The PhysicalGraph representing the physical plan of
            the logical plan in the provided context
    &#34;&#34;&#34;
    # For each stream graph node
    physical_graph = PhysicalGraph()
    
    PhysicalGraphBuilder.addNodesAndChildren(context.logical_stream_graph.root_list, physical_graph, context)
    return physical_graph</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="edna.core.plans.physicalgraph" href="index.html">edna.core.plans.physicalgraph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder" href="#edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder">PhysicalGraphBuilder</a></code></h4>
<ul class="">
<li><code><a title="edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder.addNodesAndChildren" href="#edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder.addNodesAndChildren">addNodesAndChildren</a></code></li>
<li><code><a title="edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder.buildBufferedEmit" href="#edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder.buildBufferedEmit">buildBufferedEmit</a></code></li>
<li><code><a title="edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder.buildBufferedIngest" href="#edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder.buildBufferedIngest">buildBufferedIngest</a></code></li>
<li><code><a title="edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder.convertStreamGraph" href="#edna.core.plans.physicalgraph.PhysicalGraphBuilder.PhysicalGraphBuilder.convertStreamGraph">convertStreamGraph</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>