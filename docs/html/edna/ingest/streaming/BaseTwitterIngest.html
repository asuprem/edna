<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>edna.ingest.streaming.BaseTwitterIngest API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>edna.ingest.streaming.BaseTwitterIngest</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
from edna.ingest.streaming import BaseStreamingIngest
from edna.process import BaseProcess
from edna.emit import BaseEmit
from edna.serializers.EmptySerializer import EmptyStringSerializer

from urllib.parse import urlencode
import requests
from typing import Generator, List, Dict

class BaseTwitterIngest(BaseStreamingIngest):
    &#34;&#34;&#34;Base class for streaming or filtering from Twitter using the v2 API endpoints. Subclasses can use additional
    *args and **kwargs in the `setup()` method.

    Attributes:
        tweet_fields (Dict[str, type]): Valid keys for tweet.fields from the twitter streaming API
        user_fields (Dict[str, type]): Valid keys for user.fields from the twitter streaming API
        media_fields (Dict[str, type]): Valid keys for media.fields from the twitter streaming API
        poll_fields (Dict[str, type]): Valid keys for poll.fields from the twitter streaming API
        place_fields (Dict[str, type]): Valid keys for place.fields from the twitter streaming API
        base_url (str): The endpoint for the streaming or filter request.

    Raises:
        Exception: If the instance cannot connect to the API endpoint.
        NotImplementedError: If `base_url` is not set up in the inheriting class.
        ValueError: Incorrectly formatted `base_url`

    Yields:
        (obj): A call to `__next__()` will yield a single record from the stream.
    &#34;&#34;&#34;
    tweet_fields: Dict[str,type] = {    &#34;id&#34;: str, &#34;text&#34;: str, &#34;attachments&#34;: dict, &#34;author_id&#34;: str, &#34;context_annotations&#34;: list, &#34;conversation_id&#34;: str,
                        &#34;created_at&#34;:str, &#34;entities&#34;: dict, &#34;geo&#34;: dict, &#34;in_reply_to_user_id&#34;: str, &#34;lang&#34;: str, &#34;possibly_sensitive&#34;: bool,
                        &#34;public_metrics&#34;: dict, &#34;referenced_tweets&#34;: list, &#34;source&#34;: str, &#34;withheld&#34;: dict
                        }
    user_fields: Dict[str,type] =  {     &#34;id&#34;: str, &#34;name&#34;: str, &#34;username&#34;: str, &#34;created_at&#34;: str, &#34;description&#34;: str, &#34;entities&#34;: dict, &#34;location&#34;: str,
                        &#34;pinned_tweet_id&#34;: str, &#34;profile_image_url&#34;: str, &#34;protected&#34;:bool, &#34;public_metrics&#34;: dict, &#34;url&#34;: str, &#34;verified&#34;: bool,
                        &#34;withheld&#34;: dict
                        }
    media_fields: Dict[str,type] = {    &#34;media_key&#34;: str, &#34;type&#34;: str, &#34;duration_ms&#34;: int, &#34;height&#34;: int, &#34;preview_image_url&#34;: str, &#34;public_metrics&#34;: dict, 
                        &#34;width&#34;: int
                        }
    poll_fields: Dict[str,type] =  {     &#34;id&#34;: str, &#34;options&#34;: list, &#34;duration_minutes&#34;: int, &#34;end_datetime&#34;: &#34;str&#34;, &#34;voting_status&#34;: str
                        }
    place_fields: Dict[str,type] = {    &#34;full_name&#34;: str, &#34;id&#34;: str, &#34;contained_within&#34;: list, &#34;country&#34;: str, &#34;country_code&#34;: str, &#34;geo&#34;: dict, &#34;name&#34;: str,
                        &#34;place_type&#34;: str
                        }

    base_url : str

    def __init__(self, serializer: EmptyStringSerializer, bearer_token: str, tweet_fields: List[str] = None, user_fields: List[str] = None, media_fields: List[str] = None, 
                    poll_fields: List[str] = None, place_fields: List[str] = None, *args, **kwargs):
        &#34;&#34;&#34;Initializes the BaseTwitterIngest class with the `bearer_token` for authentication and 
        query fields to populate the received tweet object 

        Args:
            serializer (EmptyStringSerializer): An empty serializer for convention.
            bearer_token (str): The authenticating v2 bearer token from a Twitter Developer account.
            tweet_fields (List[str], optional): List of tweet fields to retrieve. Defaults to None.
            user_fields (List[str], optional): List of user fields to retrieve. Defaults to None.
            media_fields (List[str], optional): List of media fields to retrieve. Defaults to None.
            poll_fields (List[str], optional): List of poll fields to retrieve. Defaults to None.
            place_fields (List[str], optional): List of place fields to retrieve. Defaults to None.
        &#34;&#34;&#34;

        tweet_fields = self.verify_fields(tweet_fields, self.tweet_fields)
        user_fields = self.verify_fields(user_fields, self.user_fields)
        media_fields = self.verify_fields(media_fields, self.media_fields)
        poll_fields = self.verify_fields(poll_fields, self.poll_fields)
        place_fields = self.verify_fields(place_fields, self.place_fields)

        self.url = self.build_url(tweet_fields, user_fields, media_fields, poll_fields, place_fields)
        self.bearer_token = bearer_token
        self.headers = self.create_headers(self.bearer_token)
        self.running = False
        self.response = Generator
        self.setup(*args, **kwargs)
        super().__init__(serializer=serializer, *args, **kwargs)

    def next(self):
        &#34;&#34;&#34;Sets up a connection to the Twitter API endpoint and retrieves records

        Returns:
            (obj): A single record from the Twitter stream
        &#34;&#34;&#34;
        if not self.running:
            self.response = self.build_response()
            self.running = True
        return next(self.response)
            
    def build_response(self):
        &#34;&#34;&#34;Builds a response object to connect to the Twitter stream and returns a generator to yield records.

        Raises:
            Exception: If the instance cannot connect to the API endpoint.

        Yields:
            (Generator): A response generator the yields records from the Twitter stream.
        &#34;&#34;&#34;
        response = requests.request(&#34;GET&#34;, self.url, headers= self.headers, stream=True)
        if response.status_code != 200:
            raise Exception(&#34;Cannot get stream (HTTP {}): {}&#34;.format(response.status_code, response.text))
        for record in response.iter_lines():
            yield record

    def verify_fields(self, passed_field: List[str], referenced_field: Dict[str, str]):
        &#34;&#34;&#34;A helper function to verify the requested fields.

        Args:
            passed_field (List[str]): The passed list of requested fields.
            referenced_field (Dict[str, str]): The internal fields to compare against.

        Returns:
            (List / None): Returns the filtered list of fields or None if no fields are valid.
        &#34;&#34;&#34;
        if passed_field is not None:
            valid_fields = [item for item in passed_field if item in referenced_field]
            if len(valid_fields) &gt; 0:
                return valid_fields
        return None

    def build_url(self, tweet_fields: List[str] = None, user_fields: List[str] = None, media_fields: List[str] = None, 
                        poll_fields: List[str] = None, place_fields: List[str] = None):
        &#34;&#34;&#34;Helper function to build the query url

        Args:
            tweet_fields (List[str], optional): List of tweet fields to retrieve. Defaults to None.
            user_fields (List[str], optional): List of user fields to retrieve. Defaults to None.
            media_fields (List[str], optional): List of media fields to retrieve. Defaults to None.
            poll_fields (List[str], optional): List of poll fields to retrieve. Defaults to None.
            place_fields (List[str], optional): List of place fields to retrieve. Defaults to None.

        Raises:
            NotImplementedError: If `base_url` is not set up in the inheriting class.
            ValueError: Incorrectly formatted `base_url`

        Returns:
            (str): Properly formatted url for streaming records.
        &#34;&#34;&#34;
        if self.base_url is None:
            raise NotImplementedError
        if self.base_url[-1] != &#34;?&#34;:
            raise ValueError(&#34;Base URL does not end with &#39;?&#39;: {base_url}&#34;.format(base_url = self.base_url))
        vars = {    &#34;tweet.fields&#34;:tweet_fields, 
                    &#34;user.fields&#34;:user_fields, 
                    &#34;place.fields&#34;:place_fields,
                    &#34;media.fields&#34;:media_fields,
                    &#34;poll.fields&#34;:poll_fields   }
        vars = {item:&#34;,&#34;.join(vars[item]) for item in vars if vars[item] is not None}
        encoded_suffix = urlencode(vars)
        if len(encoded_suffix):
            return self.base_url+urlencode(vars)
        else:
            return self.base_url[:-1]

    def create_headers(self, bearer_token: str):
        &#34;&#34;&#34;Helper function to create headers for a request.

        Args:
            bearer_token (str): Authenticating v2 bearer token.

        Returns:
            (dict): Header object
        &#34;&#34;&#34;
        return {&#34;Authorization&#34;: &#34;Bearer {}&#34;.format(bearer_token)}

    def setup(self, *args, **kwargs):
        pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest"><code class="flex name class">
<span>class <span class="ident">BaseTwitterIngest</span></span>
<span>(</span><span>serializer: EmptyStringSerializer, bearer_token: str, tweet_fields: List[str] = None, user_fields: List[str] = None, media_fields: List[str] = None, poll_fields: List[str] = None, place_fields: List[str] = None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for streaming or filtering from Twitter using the v2 API endpoints. Subclasses can use additional
<em>args and </em>*kwargs in the <code>setup()</code> method.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>tweet_fields</code></strong> :&ensp;<code>Dict[str, type]</code></dt>
<dd>Valid keys for tweet.fields from the twitter streaming API</dd>
<dt><strong><code>user_fields</code></strong> :&ensp;<code>Dict[str, type]</code></dt>
<dd>Valid keys for user.fields from the twitter streaming API</dd>
<dt><strong><code>media_fields</code></strong> :&ensp;<code>Dict[str, type]</code></dt>
<dd>Valid keys for media.fields from the twitter streaming API</dd>
<dt><strong><code>poll_fields</code></strong> :&ensp;<code>Dict[str, type]</code></dt>
<dd>Valid keys for poll.fields from the twitter streaming API</dd>
<dt><strong><code>place_fields</code></strong> :&ensp;<code>Dict[str, type]</code></dt>
<dd>Valid keys for place.fields from the twitter streaming API</dd>
<dt><strong><code>base_url</code></strong> :&ensp;<code>str</code></dt>
<dd>The endpoint for the streaming or filter request.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If the instance cannot connect to the API endpoint.</dd>
<dt><code>NotImplementedError</code></dt>
<dd>If <code>base_url</code> is not set up in the inheriting class.</dd>
<dt><code>ValueError</code></dt>
<dd>Incorrectly formatted <code>base_url</code></dd>
</dl>
<h2 id="yields">Yields</h2>
<p>(obj): A call to <code>__next__()</code> will yield a single record from the stream.
Initializes the BaseTwitterIngest class with the <code>bearer_token</code> for authentication and
query fields to populate the received tweet object </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>serializer</code></strong> :&ensp;<code>EmptyStringSerializer</code></dt>
<dd>An empty serializer for convention.</dd>
<dt><strong><code>bearer_token</code></strong> :&ensp;<code>str</code></dt>
<dd>The authenticating v2 bearer token from a Twitter Developer account.</dd>
<dt><strong><code>tweet_fields</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of tweet fields to retrieve. Defaults to None.</dd>
<dt><strong><code>user_fields</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of user fields to retrieve. Defaults to None.</dd>
<dt><strong><code>media_fields</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of media fields to retrieve. Defaults to None.</dd>
<dt><strong><code>poll_fields</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of poll fields to retrieve. Defaults to None.</dd>
<dt><strong><code>place_fields</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of place fields to retrieve. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseTwitterIngest(BaseStreamingIngest):
    &#34;&#34;&#34;Base class for streaming or filtering from Twitter using the v2 API endpoints. Subclasses can use additional
    *args and **kwargs in the `setup()` method.

    Attributes:
        tweet_fields (Dict[str, type]): Valid keys for tweet.fields from the twitter streaming API
        user_fields (Dict[str, type]): Valid keys for user.fields from the twitter streaming API
        media_fields (Dict[str, type]): Valid keys for media.fields from the twitter streaming API
        poll_fields (Dict[str, type]): Valid keys for poll.fields from the twitter streaming API
        place_fields (Dict[str, type]): Valid keys for place.fields from the twitter streaming API
        base_url (str): The endpoint for the streaming or filter request.

    Raises:
        Exception: If the instance cannot connect to the API endpoint.
        NotImplementedError: If `base_url` is not set up in the inheriting class.
        ValueError: Incorrectly formatted `base_url`

    Yields:
        (obj): A call to `__next__()` will yield a single record from the stream.
    &#34;&#34;&#34;
    tweet_fields: Dict[str,type] = {    &#34;id&#34;: str, &#34;text&#34;: str, &#34;attachments&#34;: dict, &#34;author_id&#34;: str, &#34;context_annotations&#34;: list, &#34;conversation_id&#34;: str,
                        &#34;created_at&#34;:str, &#34;entities&#34;: dict, &#34;geo&#34;: dict, &#34;in_reply_to_user_id&#34;: str, &#34;lang&#34;: str, &#34;possibly_sensitive&#34;: bool,
                        &#34;public_metrics&#34;: dict, &#34;referenced_tweets&#34;: list, &#34;source&#34;: str, &#34;withheld&#34;: dict
                        }
    user_fields: Dict[str,type] =  {     &#34;id&#34;: str, &#34;name&#34;: str, &#34;username&#34;: str, &#34;created_at&#34;: str, &#34;description&#34;: str, &#34;entities&#34;: dict, &#34;location&#34;: str,
                        &#34;pinned_tweet_id&#34;: str, &#34;profile_image_url&#34;: str, &#34;protected&#34;:bool, &#34;public_metrics&#34;: dict, &#34;url&#34;: str, &#34;verified&#34;: bool,
                        &#34;withheld&#34;: dict
                        }
    media_fields: Dict[str,type] = {    &#34;media_key&#34;: str, &#34;type&#34;: str, &#34;duration_ms&#34;: int, &#34;height&#34;: int, &#34;preview_image_url&#34;: str, &#34;public_metrics&#34;: dict, 
                        &#34;width&#34;: int
                        }
    poll_fields: Dict[str,type] =  {     &#34;id&#34;: str, &#34;options&#34;: list, &#34;duration_minutes&#34;: int, &#34;end_datetime&#34;: &#34;str&#34;, &#34;voting_status&#34;: str
                        }
    place_fields: Dict[str,type] = {    &#34;full_name&#34;: str, &#34;id&#34;: str, &#34;contained_within&#34;: list, &#34;country&#34;: str, &#34;country_code&#34;: str, &#34;geo&#34;: dict, &#34;name&#34;: str,
                        &#34;place_type&#34;: str
                        }

    base_url : str

    def __init__(self, serializer: EmptyStringSerializer, bearer_token: str, tweet_fields: List[str] = None, user_fields: List[str] = None, media_fields: List[str] = None, 
                    poll_fields: List[str] = None, place_fields: List[str] = None, *args, **kwargs):
        &#34;&#34;&#34;Initializes the BaseTwitterIngest class with the `bearer_token` for authentication and 
        query fields to populate the received tweet object 

        Args:
            serializer (EmptyStringSerializer): An empty serializer for convention.
            bearer_token (str): The authenticating v2 bearer token from a Twitter Developer account.
            tweet_fields (List[str], optional): List of tweet fields to retrieve. Defaults to None.
            user_fields (List[str], optional): List of user fields to retrieve. Defaults to None.
            media_fields (List[str], optional): List of media fields to retrieve. Defaults to None.
            poll_fields (List[str], optional): List of poll fields to retrieve. Defaults to None.
            place_fields (List[str], optional): List of place fields to retrieve. Defaults to None.
        &#34;&#34;&#34;

        tweet_fields = self.verify_fields(tweet_fields, self.tweet_fields)
        user_fields = self.verify_fields(user_fields, self.user_fields)
        media_fields = self.verify_fields(media_fields, self.media_fields)
        poll_fields = self.verify_fields(poll_fields, self.poll_fields)
        place_fields = self.verify_fields(place_fields, self.place_fields)

        self.url = self.build_url(tweet_fields, user_fields, media_fields, poll_fields, place_fields)
        self.bearer_token = bearer_token
        self.headers = self.create_headers(self.bearer_token)
        self.running = False
        self.response = Generator
        self.setup(*args, **kwargs)
        super().__init__(serializer=serializer, *args, **kwargs)

    def next(self):
        &#34;&#34;&#34;Sets up a connection to the Twitter API endpoint and retrieves records

        Returns:
            (obj): A single record from the Twitter stream
        &#34;&#34;&#34;
        if not self.running:
            self.response = self.build_response()
            self.running = True
        return next(self.response)
            
    def build_response(self):
        &#34;&#34;&#34;Builds a response object to connect to the Twitter stream and returns a generator to yield records.

        Raises:
            Exception: If the instance cannot connect to the API endpoint.

        Yields:
            (Generator): A response generator the yields records from the Twitter stream.
        &#34;&#34;&#34;
        response = requests.request(&#34;GET&#34;, self.url, headers= self.headers, stream=True)
        if response.status_code != 200:
            raise Exception(&#34;Cannot get stream (HTTP {}): {}&#34;.format(response.status_code, response.text))
        for record in response.iter_lines():
            yield record

    def verify_fields(self, passed_field: List[str], referenced_field: Dict[str, str]):
        &#34;&#34;&#34;A helper function to verify the requested fields.

        Args:
            passed_field (List[str]): The passed list of requested fields.
            referenced_field (Dict[str, str]): The internal fields to compare against.

        Returns:
            (List / None): Returns the filtered list of fields or None if no fields are valid.
        &#34;&#34;&#34;
        if passed_field is not None:
            valid_fields = [item for item in passed_field if item in referenced_field]
            if len(valid_fields) &gt; 0:
                return valid_fields
        return None

    def build_url(self, tweet_fields: List[str] = None, user_fields: List[str] = None, media_fields: List[str] = None, 
                        poll_fields: List[str] = None, place_fields: List[str] = None):
        &#34;&#34;&#34;Helper function to build the query url

        Args:
            tweet_fields (List[str], optional): List of tweet fields to retrieve. Defaults to None.
            user_fields (List[str], optional): List of user fields to retrieve. Defaults to None.
            media_fields (List[str], optional): List of media fields to retrieve. Defaults to None.
            poll_fields (List[str], optional): List of poll fields to retrieve. Defaults to None.
            place_fields (List[str], optional): List of place fields to retrieve. Defaults to None.

        Raises:
            NotImplementedError: If `base_url` is not set up in the inheriting class.
            ValueError: Incorrectly formatted `base_url`

        Returns:
            (str): Properly formatted url for streaming records.
        &#34;&#34;&#34;
        if self.base_url is None:
            raise NotImplementedError
        if self.base_url[-1] != &#34;?&#34;:
            raise ValueError(&#34;Base URL does not end with &#39;?&#39;: {base_url}&#34;.format(base_url = self.base_url))
        vars = {    &#34;tweet.fields&#34;:tweet_fields, 
                    &#34;user.fields&#34;:user_fields, 
                    &#34;place.fields&#34;:place_fields,
                    &#34;media.fields&#34;:media_fields,
                    &#34;poll.fields&#34;:poll_fields   }
        vars = {item:&#34;,&#34;.join(vars[item]) for item in vars if vars[item] is not None}
        encoded_suffix = urlencode(vars)
        if len(encoded_suffix):
            return self.base_url+urlencode(vars)
        else:
            return self.base_url[:-1]

    def create_headers(self, bearer_token: str):
        &#34;&#34;&#34;Helper function to create headers for a request.

        Args:
            bearer_token (str): Authenticating v2 bearer token.

        Returns:
            (dict): Header object
        &#34;&#34;&#34;
        return {&#34;Authorization&#34;: &#34;Bearer {}&#34;.format(bearer_token)}

    def setup(self, *args, **kwargs):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="edna.ingest.streaming.BaseStreamingIngest" href="index.html#edna.ingest.streaming.BaseStreamingIngest">BaseStreamingIngest</a></li>
<li><a title="edna.ingest.BaseIngest" href="../index.html#edna.ingest.BaseIngest">BaseIngest</a></li>
<li><a title="edna.core.primitives.EdnaPrimitive" href="../../core/primitives/index.html#edna.core.primitives.EdnaPrimitive">EdnaPrimitive</a></li>
<li>collections.abc.Iterator</li>
<li>collections.abc.Iterable</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="edna.ingest.streaming.TwitterFilteredIngest.TwitterFilteredIngest" href="TwitterFilteredIngest.html#edna.ingest.streaming.TwitterFilteredIngest.TwitterFilteredIngest">TwitterFilteredIngest</a></li>
<li><a title="edna.ingest.streaming.TwitterStreamingIngest.TwitterStreamingIngest" href="TwitterStreamingIngest.html#edna.ingest.streaming.TwitterStreamingIngest.TwitterStreamingIngest">TwitterStreamingIngest</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.base_url"><code class="name">var <span class="ident">base_url</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.media_fields"><code class="name">var <span class="ident">media_fields</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.place_fields"><code class="name">var <span class="ident">place_fields</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.poll_fields"><code class="name">var <span class="ident">poll_fields</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.tweet_fields"><code class="name">var <span class="ident">tweet_fields</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.user_fields"><code class="name">var <span class="ident">user_fields</span> : Dict[str, type]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.build_response"><code class="name flex">
<span>def <span class="ident">build_response</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds a response object to connect to the Twitter stream and returns a generator to yield records.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If the instance cannot connect to the API endpoint.</dd>
</dl>
<h2 id="yields">Yields</h2>
<p>(Generator): A response generator the yields records from the Twitter stream.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_response(self):
    &#34;&#34;&#34;Builds a response object to connect to the Twitter stream and returns a generator to yield records.

    Raises:
        Exception: If the instance cannot connect to the API endpoint.

    Yields:
        (Generator): A response generator the yields records from the Twitter stream.
    &#34;&#34;&#34;
    response = requests.request(&#34;GET&#34;, self.url, headers= self.headers, stream=True)
    if response.status_code != 200:
        raise Exception(&#34;Cannot get stream (HTTP {}): {}&#34;.format(response.status_code, response.text))
    for record in response.iter_lines():
        yield record</code></pre>
</details>
</dd>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.build_url"><code class="name flex">
<span>def <span class="ident">build_url</span></span>(<span>self, tweet_fields: List[str] = None, user_fields: List[str] = None, media_fields: List[str] = None, poll_fields: List[str] = None, place_fields: List[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to build the query url</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tweet_fields</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of tweet fields to retrieve. Defaults to None.</dd>
<dt><strong><code>user_fields</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of user fields to retrieve. Defaults to None.</dd>
<dt><strong><code>media_fields</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of media fields to retrieve. Defaults to None.</dd>
<dt><strong><code>poll_fields</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of poll fields to retrieve. Defaults to None.</dd>
<dt><strong><code>place_fields</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of place fields to retrieve. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NotImplementedError</code></dt>
<dd>If <code>base_url</code> is not set up in the inheriting class.</dd>
<dt><code>ValueError</code></dt>
<dd>Incorrectly formatted <code>base_url</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(str): Properly formatted url for streaming records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_url(self, tweet_fields: List[str] = None, user_fields: List[str] = None, media_fields: List[str] = None, 
                    poll_fields: List[str] = None, place_fields: List[str] = None):
    &#34;&#34;&#34;Helper function to build the query url

    Args:
        tweet_fields (List[str], optional): List of tweet fields to retrieve. Defaults to None.
        user_fields (List[str], optional): List of user fields to retrieve. Defaults to None.
        media_fields (List[str], optional): List of media fields to retrieve. Defaults to None.
        poll_fields (List[str], optional): List of poll fields to retrieve. Defaults to None.
        place_fields (List[str], optional): List of place fields to retrieve. Defaults to None.

    Raises:
        NotImplementedError: If `base_url` is not set up in the inheriting class.
        ValueError: Incorrectly formatted `base_url`

    Returns:
        (str): Properly formatted url for streaming records.
    &#34;&#34;&#34;
    if self.base_url is None:
        raise NotImplementedError
    if self.base_url[-1] != &#34;?&#34;:
        raise ValueError(&#34;Base URL does not end with &#39;?&#39;: {base_url}&#34;.format(base_url = self.base_url))
    vars = {    &#34;tweet.fields&#34;:tweet_fields, 
                &#34;user.fields&#34;:user_fields, 
                &#34;place.fields&#34;:place_fields,
                &#34;media.fields&#34;:media_fields,
                &#34;poll.fields&#34;:poll_fields   }
    vars = {item:&#34;,&#34;.join(vars[item]) for item in vars if vars[item] is not None}
    encoded_suffix = urlencode(vars)
    if len(encoded_suffix):
        return self.base_url+urlencode(vars)
    else:
        return self.base_url[:-1]</code></pre>
</details>
</dd>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.create_headers"><code class="name flex">
<span>def <span class="ident">create_headers</span></span>(<span>self, bearer_token: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to create headers for a request.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bearer_token</code></strong> :&ensp;<code>str</code></dt>
<dd>Authenticating v2 bearer token.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(dict): Header object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_headers(self, bearer_token: str):
    &#34;&#34;&#34;Helper function to create headers for a request.

    Args:
        bearer_token (str): Authenticating v2 bearer token.

    Returns:
        (dict): Header object
    &#34;&#34;&#34;
    return {&#34;Authorization&#34;: &#34;Bearer {}&#34;.format(bearer_token)}</code></pre>
</details>
</dd>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up a connection to the Twitter API endpoint and retrieves records</p>
<h2 id="returns">Returns</h2>
<p>(obj): A single record from the Twitter stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next(self):
    &#34;&#34;&#34;Sets up a connection to the Twitter API endpoint and retrieves records

    Returns:
        (obj): A single record from the Twitter stream
    &#34;&#34;&#34;
    if not self.running:
        self.response = self.build_response()
        self.running = True
    return next(self.response)</code></pre>
</details>
</dd>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self, *args, **kwargs):
    pass</code></pre>
</details>
</dd>
<dt id="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.verify_fields"><code class="name flex">
<span>def <span class="ident">verify_fields</span></span>(<span>self, passed_field: List[str], referenced_field: Dict[str, str])</span>
</code></dt>
<dd>
<div class="desc"><p>A helper function to verify the requested fields.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>passed_field</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>The passed list of requested fields.</dd>
<dt><strong><code>referenced_field</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>The internal fields to compare against.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(List / None): Returns the filtered list of fields or None if no fields are valid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_fields(self, passed_field: List[str], referenced_field: Dict[str, str]):
    &#34;&#34;&#34;A helper function to verify the requested fields.

    Args:
        passed_field (List[str]): The passed list of requested fields.
        referenced_field (Dict[str, str]): The internal fields to compare against.

    Returns:
        (List / None): Returns the filtered list of fields or None if no fields are valid.
    &#34;&#34;&#34;
    if passed_field is not None:
        valid_fields = [item for item in passed_field if item in referenced_field]
        if len(valid_fields) &gt; 0:
            return valid_fields
    return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="edna.ingest.streaming.BaseStreamingIngest" href="index.html#edna.ingest.streaming.BaseStreamingIngest">BaseStreamingIngest</a></b></code>:
<ul class="hlist">
<li><code><a title="edna.ingest.streaming.BaseStreamingIngest.__iter__" href="index.html#edna.ingest.streaming.BaseStreamingIngest.__iter__">__iter__</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseStreamingIngest.__next__" href="index.html#edna.ingest.streaming.BaseStreamingIngest.__next__">__next__</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseStreamingIngest.build" href="index.html#edna.ingest.streaming.BaseStreamingIngest.build">build</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseStreamingIngest.close" href="index.html#edna.ingest.streaming.BaseStreamingIngest.close">close</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="edna.ingest.streaming" href="index.html">edna.ingest.streaming</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest">BaseTwitterIngest</a></code></h4>
<ul class="two-column">
<li><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.base_url" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.base_url">base_url</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.build_response" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.build_response">build_response</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.build_url" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.build_url">build_url</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.create_headers" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.create_headers">create_headers</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.media_fields" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.media_fields">media_fields</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.next" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.next">next</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.place_fields" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.place_fields">place_fields</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.poll_fields" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.poll_fields">poll_fields</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.setup" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.setup">setup</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.tweet_fields" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.tweet_fields">tweet_fields</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.user_fields" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.user_fields">user_fields</a></code></li>
<li><code><a title="edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.verify_fields" href="#edna.ingest.streaming.BaseTwitterIngest.BaseTwitterIngest.verify_fields">verify_fields</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>