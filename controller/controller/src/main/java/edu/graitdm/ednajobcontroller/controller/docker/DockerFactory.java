package edu.graitdm.ednajobcontroller.controller.docker;

import com.github.dockerjava.api.DockerClient;
import com.github.dockerjava.api.command.BuildImageResultCallback;
import com.github.dockerjava.api.model.BuildResponseItem;
import com.github.dockerjava.core.command.PushImageResultCallback;
import com.google.common.base.Charsets;
import com.google.common.io.Resources;
import com.hubspot.jinjava.Jinjava;
import edu.graitdm.ednajobcontroller.configuration.BaseConfiguration;
import edu.graitdm.ednajobcontroller.controller.ednajob.EdnaJob;
import lombok.SneakyThrows;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.FileOutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
import static java.util.Objects.nonNull;

/**
 * <code>DockerFactory</code> generates docker images for an Edna Job, tags them, and pushes them to a private
 * registry so that the deployment generated by the
 * {@link edu.graitdm.ednajobcontroller.controller.deployment.DeploymentFactory} can use it to run an Edna Job.
 *
 * TODO We need to adjust this so new images can be constructed in a controller running in Kubernetes. This would involve
 *  a bunch of steps -- require that these edna jobs have no large file dependency. Then have an edna client submit jobs
 *  and their associated files to the controller's REST endpoint. Then, when controller receives the payload
 *  it will generate the docker image and apply the received ednajob.yaml. In that case, docker image will be
 *  generated by a EdnaJobImage controller.
 *
 */
public class DockerFactory {

    private static final Logger LOGGER = LoggerFactory.getLogger(DockerFactory.class.getSimpleName());

    private final DockerClient dockerClient;
    private final BaseConfiguration configuration;

    /**
     * A custom {@link BuildImageResultCallback} that logs the text content of an Http Response Object
     * to the Log at an INFO log-level (in addition to the logging of the entire Response Object
     * at DEBUG log-level in the parent.
     */
    private static class DockerBuildImageResultCallback extends BuildImageResultCallback {
        private Logger LOGGER;
        private String imageId;
        private String error;

        /**
         * Constructor for the <code>DockerBuildImageResultCallback</code>
         * @param logger An instance of a {@link Logger} passed from {@link DockerFactory}
         */
        DockerBuildImageResultCallback(Logger logger) {
            this.LOGGER = logger;
        }

        /**
         * Method that is called whenever a {@link BuildResponseItem} is received. Our version logs the text content
         * of the HTTP Response item to the logger at INFO log-level, and also calls the super.
         *
         * @param item A {@link BuildResponseItem} item.
         */
        public void onNext(BuildResponseItem item) {
            String text = item.getStream();
            if(nonNull(text)){
                LOGGER.info(StringUtils.removeEnd(text, "\n"));
            }
            super.onNext(item);

        }

    }

    /**
     * Constructor for <code>DockerFactory</code>
     *
     * @param dockerClient A instance of {@link DockerClient} to connect to the docker daemon.
     * @param configuration Instance of the {@link BaseConfiguration}.
     */
    public DockerFactory(DockerClient dockerClient, BaseConfiguration configuration){
        this.dockerClient = dockerClient;
        this.configuration = configuration;
    }



    /**
     * Method to build a docker image for an <code>EdnaJob</code>, tag it, and save it to a private registry.
     *
     * @param ednaJob An {@link EdnaJob} custom resource.
     */
    @SneakyThrows
    public void add(EdnaJob ednaJob) {
        LOGGER.info("Starting image building.");
        Path context = Paths.get(configuration.getEdnaAppdir(),
                    ednaJob.getSpec().getApplicationname(),
                    ednaJob.getSpec().getJobname());
        LOGGER.info("Got path to context at {}", context.toString());        

        Path ednaSource = Paths.get(configuration.getEdnaSourcedir());
        LOGGER.info("Got path to edna source files at {}", ednaSource.toString());

        Map<String,String> jinjaContext = new HashMap<String, String>();
        jinjaContext.put("filename", ednaJob.getSpec().getFilename());
        jinjaContext.put("jobcontext", ednaJob.getSpec().getJobcontext());
        jinjaContext.put("jobdependencies", ednaJob.getSpec().getJobdependencies());
        jinjaContext.put("filedependencies", ednaJob.getSpec().getFiledependencies());
        LOGGER.info("Finished setting up jinja context,");

        // Extract the jinja2 tempate from the resources directory with Resources.toString (see see https://github.com/HubSpot/jinjava)
        String template = Resources.toString(Resources.getResource("Dockerfile.jinja2"), Charsets.UTF_8);
        LOGGER.info("Retrieved Dockerfile template.");


        Jinjava jinjava = new Jinjava();
        String renderedDockerfile = jinjava.render(template,jinjaContext);
        LOGGER.info("Completed rendering Dockerfile.");
        //Save the renderedDockerfile to context/Dockerfile; TODO catch IoExeption?
        Files.writeString(context.resolve("Dockerfile"), renderedDockerfile, Charsets.UTF_8);
        LOGGER.info("Saved Dockerfile to {}",context.resolve("Dockerfile").toString());

        var fop = new FileOutputStream(context.resolve(".dockerignore").toString());
        Resources.copy(Resources.getResource(".dockerignore"),fop);
        fop.close();
        LOGGER.info("Saved .dockerignore to {}",context.resolve(".dockerignore").toString());

        LOGGER.info("Starting copy of edna source directory and setup files",context.toString());
        FileUtils.copyDirectory(ednaSource.resolve("src").toFile(), context.resolve("src").toFile());
        LOGGER.info("Finished copying edna source files to {}",context.resolve("src").toString());
        Files.copy(ednaSource.resolve("setup.cfg"), context.resolve("setup.cfg"), REPLACE_EXISTING);
        LOGGER.info("Finished copying edna setup configuration file to {}",context.resolve("setup.cfg").toString());
        Files.copy(ednaSource.resolve("setup.py"), context.resolve("setup.py"), REPLACE_EXISTING);
        LOGGER.info("Finished copying edna setup script to {}",context.resolve("setup.py").toString());

        // Get the image details
        String localImageName = ednaJob.getSpec().getApplicationname() + "-" +
                ednaJob.getSpec().getJobname() + ":" +
                ednaJob.getSpec().getJobimagetag();
        String remoteImageRepository = ednaJob.getSpec().getRegistryhost() + ":" +
                ednaJob.getSpec().getRegistryport() + "/" +
                ednaJob.getSpec().getApplicationname() + "-" +
                ednaJob.getSpec().getJobname();

        LOGGER.info("Starting docker image build");
        String imageId = dockerClient.buildImageCmd()
                .withBaseDirectory(context.toFile())
                .withDockerfile(context.resolve("Dockerfile").toFile())  // or use withDockerfile
                .withPull(true)
                .withNoCache(true)
                .withTags(Collections.singleton(localImageName))
                .exec(new DockerBuildImageResultCallback(LOGGER))
                .awaitImageId();
        LOGGER.info("Finished building docker image at {}", localImageName);
        
        dockerClient.tagImageCmd(imageId, remoteImageRepository, ednaJob.getSpec().getJobimagetag()).exec();
        LOGGER.info("Tagged docker image at {}", remoteImageRepository+":"+ednaJob.getSpec().getJobimagetag());
        // TODO (Abhijit) This throws InterruptedException
        LOGGER.info("Starting image push to registry");
        dockerClient.pushImageCmd(remoteImageRepository)
                .withTag(ednaJob.getSpec().getJobimagetag())
                .exec(new PushImageResultCallback())
                .awaitCompletion();
        LOGGER.info("Pushed docker image to registry");

        LOGGER.info("Cleaning up docker context");
        FileUtils.deleteDirectory(context.resolve("src").toFile());
        Files.delete(context.resolve("setup.cfg"));
        Files.delete(context.resolve("setup.py"));
        Files.delete(context.resolve("Dockerfile"));
        Files.delete(context.resolve(".dockerignore"));
    }


}
